# %%
import numpy as np

# %%

def is_pos(x):
    return x >= 0.0

def get_y(x, threshold=0.0, logic='and'):
    """
    Returns y based on given logic. The default logic is AND. For example, 
    if x1 >= threshold and x2 >= threshold then y = 1, else y = 0.

    Parameters
    ----------
    x: array_like
        An array of n by 2 matrix.

    threshold: float (default=0.0)
        The threshold of the logic.

    logic: 'and', 'xor' or 'or' (default='and')

    Returns
    -------
    y: darray
        Array of labels.
    """

    t = threshold
    if logic == 'and':
        return np.array(
            [1 if is_pos(xx[0]-t) and is_pos(xx[1]-t) else 0 for xx in x], dtype=np.int)
    elif logic == 'or':
        return np.array(
            [1 if is_pos(xx[0]-t) or is_pos(xx[1]-t) else 0 for xx in x], dtype=np.int)
    elif logic == 'xor':
        return np.array(
            [1 if is_pos(xx[0]-t) != is_pos(xx[1]-t) else 0 for xx in x], dtype=np.int)
    else:
        raise Exception('Unacceptable parameter for logic.')


# %%
def get_not_y(y):
    """
    Apply logical not on y and return it

    Parameters
    ----------
    y: array
        Array of binary labels

    Returns
    -------
    outputs: array
        Array of binary labels after logical not applied on y
    """
    return np.array(np.logical_not(y), dtype=np.int)

# %%


def generate_logistic_samples(n=1000, threshold=0.5,
        scale=0.15, centre=None, logic='and', random_state=None):
    """
    Returns random samples to simulate AND logic (0^0=0, 0^1=0, 1^0=0, 1^1=1).
    The random samples are generated by Logistic Distribution.

    Parameters
    ----------
    n: int
        # of samples.

    threshold: float (default=0.5)
        The threshold of AND logic. The default is 0.5.

    scale: float (default=0.15)
        The scale parameter for Logistic Distribution. If generating sample
        with 4 blobs, set scale to 0.025.

    centre: array (default=None)
        An array with 2 float values.
        If it is None, samples are generated around threshold. Else, generating 
        a blob based on the centre.

    logic: 'and', 'xor' or 'or' (default='and')

    random_state: int (default=None)
        If int, random_state is the seed used by the random number generator.  
        If None, the random number generator is the RandomState instance used  
        by `np.random`.

    Returns
    -------
    x: array
        Array of n by 2 matrix.

    y: array
        Array of n by 1 coresponding labels for x.
    """
    if random_state is not None:
        np.random.seed(seed=random_state)

    if ((isinstance(centre, type([])) or
            isinstance(centre, type(np.array([])))) and
            len(centre) == 2):
        # feature 1
        x = np.random.logistic(centre[0], scale=scale, size=n)
        # feature 2
        x = np.append(
            x,
            np.random.logistic(centre[1], scale=scale, size=n))
        # after reshape: [[1,1,1],[2,2,2]]
        x = x.reshape((2, n))
        x = np.transpose(x)
    else:
        x = np.random.logistic(threshold, scale, n * 2)
        x = x.reshape((n, 2))
    y = get_y(x, threshold, logic=logic)
    return x, y

# %%


def generate_uniform_samples(n=1000, threshold=0.5, radius=1.0, 
        logic='and', random_state=None):
    """
    Returns random samples to simulate AND logic (0^0=0, 0^1=0, 1^0=0, 1^1=1).
    The random samples are generated by Uniform Distribution.

    Parameters
    ----------
    n: int
        # of samples.

    threshold: float (default=0.5)
        The threshold of AND logic. The default is 0.5.

    radius: float (default=1.5)
        Min = threshold - radius; Max = threshold + radius
    
    logic: 'and', 'xor' or 'or' (default='and')

    random_state: int (default=None)
        If int, random_state is the seed used by the random number generator.  
        If None, the random number generator is the RandomState instance used  
        by `np.random`.

    Returns
    -------
    x: array
        Array of n by 2 matrix.

    y: array
        Array of n by 1 coresponding labels for x.
    """
    if random_state is not None:
        np.random.seed(seed=random_state)

    low = threshold - radius
    high = threshold + radius
    x = np.random.uniform(low, high, n * 2)
    x = x.reshape((n, 2))
    y = get_y(x, threshold, logic=logic)
    return x, y

# %%


def get_basic_set(shift=None, norms=None, logic='and'):
    """
    Adjusting 4 base cases based on shifting and normalization

    Parameters
    ----------
    shift: [[x0, x1]]
    
    norms: [[x0, x1]]

    logic: 'and', 'xor' or 'or' (default='and')

    Returns
    -------
    x: array
        Array of n by 2 matrix.

    y: array
        Array of n by 1 coresponding labels for x.
    """
    x = np.array([
        [0, 0],
        [1, 0],
        [0, 1],
        [1, 1]], dtype=np.float32)
    y = get_y(x, threshold=0.5, logic=logic)

    if shift is not None:
        x = x + np.repeat(shift, len(x), axis=0)

    if norms is not None:
        x = x / np.repeat(norms, len(x), axis=0)

    return x, y
